{"pages":[{"title":"about","text":"Tech note for developing.by Seo. 2021.07.","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/07/14/hello-world/"},{"title":"[spring MVC] @RequestMapping","text":"기본 요청 @RequestMapping123456789@Slf4j@RestControllerpublic class MappingController { @RequestMapping({&quot;/hello-basic&quot;, &quot;/hello&quot;}) public String helloBasic() { log.info(&quot;hello-Basic&quot;); return &quot;ok&quot;; } “/hello-basic” 또는 “/hello” url 호출 시, 해당 메서드가 실행되도록 매핑해준다. Http 메서드를 모두 허용해준다. GET, POST, PUT 등 HTTP 메서드 매핑 특정 HTTP 메서드 요청만 허용해준다.12345@GetMapping(&quot;/mapping-get&quot;)public String mappingGet() {log.info(&quot;mappingGet&quot;); return &quot;ok&quot;;} @PostMapping, @PutMapping 등 경로 변수 사용 @PathVariable 12345@GetMapping(&quot;/mapping/{userId}&quot;)public String mappingPath(@PathVariable(&quot;userId&quot;) String data) {log.info(&quot;mappingPath userId={}&quot;, data); return &quot;ok&quot;;} 특정 parameter 조건 매핑 params=”mode=debug”, pramas = “!mode” 123456@GetMapping(value = &quot;/mapping-param&quot;, params = &quot;mode=debug&quot;)public String mappingParam() {log.info(&quot;mappingParam&quot;); return &quot;ok&quot;;}/* params에 &quot;mode=debug&quot; 포함되어야 요청을 받아들인다. 그 밖의 조건들 특정 헤더 조건 매핑: header=”..” 미디어타입 조건 매핑: consumes=”..”, produces=”..” reference","link":"/2021/07/14/%5Bspring%20MVC%5D%20@RequestMapping/"},{"title":"[spring MVC] @Controller","text":"@Controller HTTP 요청, 응답함에 있어 @controller가 지원하는 annotation들을 살펴보자. 주요 파라미터 지원 목록 Http header Http body Http API @Controller에서 사용 가능한 파라미터들: docs.spring 응답 값: docs HTTP 요청값 처리 Http 요청 데이터를 조회하는 방법: Http 요청 메시리를 통해 클라이언트가 서버로 데이터를 전달하는 방법 GET: query parameter POST: HTML form HTTP Message body에 데이터 담아서 요청: 주로 JSON @ReuqestParam 메서드 옆에 @Requestparam 추가해서 사용 123456789101112@Slf4j@Controllerpublic class RequestParamController { @ResponseBody @RequestMapping(&quot;/request-param-v2&quot;) public String requestParamV2( @RequestParam(&quot;username&quot;) String name, @RequestParam(&quot;age&quot;) int age) { log.info(&quot;userName= {}, age= {}&quot;, name, age); return &quot;Ok&quot;; } 변수를 HTTP parameter 이름과 같게 설정하면, @RequestParam(name=&quot;x&quot;) 생략 가능하다. 12345678@ResponseBody@RequestMapping(&quot;/request-param-v3&quot;)public String requestParamV3( @RequestParam String username, @RequestParam int age) { log.info(&quot;username= {}, age= {}&quot;, username, age); return &quot;ok&quot;;} @RequestParam도 생략 가능하다. 123456@ResponseBody@RequestMapping(&quot;/request-param-v4&quot;)public String requestParamV4(String username, int age) { log.info(&quot;username= {}, age= {}&quot;, username, age); return &quot;ok&quot;;} parameter 필수 여부 12345678910 @ResponseBody @RequestMapping(&quot;/request-param-required&quot;) public String requestParamRequired( @RequestParam(required = true) String username, @RequestParam(required = false) int age) {// int a = null;// Integer b = null; log.info(&quot;username= {}, age= {}&quot;, username, age); return &quot;ok&quot;; } 기본값 적용 12345678@ResponseBody@RequestMapping(&quot;/request-param-default&quot;)public String requestParamDefault( @RequestParam(required = true, defaultValue = &quot;guest&quot;) String username, @RequestParam(required = false, defaultValue = &quot;-1&quot;) int age) { log.info(&quot;username= {}, age= {}&quot;, username, age); return &quot;ok&quot;;} 파라미터를 Map으로 조회 가능하다. 1234567 @ResponseBody@RequestMapping(&quot;/request-param-map&quot;)public String requestParamMap(@RequestParam Map&lt;String, Object&gt; paramMap) { log.info(&quot;username={}, age={}&quot;, paramMap.get(&quot;username&quot;), paramMap.get(&quot;age&quot;)); return &quot;ok&quot;;} @ModelAttrubute 요청 파라미터를 받아서 필요한 객체를 만들고 그 객체에 값을 넣어주기 위해 @modelAttribute 사용한다.123456789101112131415161718192021 @ResponseBody @RequestMapping(&quot;/model-attribute-v1&quot;)/* public String modelAttributeV1(@RequestParam String username, @RequestParam int age) { HelloData helloData = new HelloData(); helloData.setUsername(username); helloData.setAge(age); log.info(&quot;username={}, age={}&quot;, helloData.getUsername(), helloData.getAge()); log.info(&quot;helloDate={}&quot;, helloData); return &quot;ok&quot;;*/ public String modelAttributeV1(@ModelAttribute HelloData helloData) { log.info(&quot;username= {}, age= {}&quot;, helloData.getUsername(), helloData.getAge()); return &quot;ok&quot;; } @ResponseBody @RequestMapping(&quot;/model-attribute-v2&quot;) public String modelAttributeV2(HelloData helloData) { log.info(&quot;username= {}, age= {}&quot;, helloData.getUsername(), helloData.getAge()); return &quot;ok&quot;; }} @RequestBody HTTP message body에 데이터를 직접 담아서 요청할때 사용한다.데이터를 담을 때, 크게 두 가지 방식이 있다. 단순 메시지 JSON @RequestBody: (Case1) 단순 메시지서블릿1234567891011@Slf4j@Controllerpublic class RequestBodyStringController { @PostMapping(&quot;/request-body-string-v1&quot;) public void requestBodyString(HttpServletRequest req, HttpServletResponse res) throws IOException { ServletInputStream inputStream = req.getInputStream(); String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;messageBody= {}&quot;, messageBody); res.getWriter().write(&quot;Ok&quot;); } spring MVC 제공 parameter: :InputStream (reader), OuterStream (writer)1234567@PostMapping(&quot;/request-body-string-v2&quot;)public void requestBodyStringV2(InputStream inputStream, Writer writer) throws IOException { String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;messageBody= {}&quot;, messageBody); writer.write(&quot;Ok&quot;);} HttpEntity: HTTP header, body 정보를 편라하게 조회 응답에서도 HttpEntity 사용 가능 12345678@PostMapping(&quot;/request-body-string-v3&quot;)public HttpEntity&lt;String&gt; requestBodyStringV3(HttpEntity&lt;String&gt; httpEntity) throws IOException { String messageBody = httpEntity.getBody(); log.info(&quot;messageBody= {}&quot;, messageBody); return new HttpEntity&lt;&gt;(&quot;Ok&quot;);} @Requestbody: 메시지 바디 정보를 직접 조회1234567 @ResponseBody @PostMapping(&quot;/request-body-string-v4&quot;) public String requestBodyStringV4(@RequestBody String messageBody){ log.info(&quot;messageBody={}&quot;, messageBody); return &quot;Ok&quot;; }} @RequestBody: (Case2) JSONServlet 사용123456789101112131415@Slf4j@Controllerpublic class RequestBodyJsonController { private ObjectMapper objectMapper = new ObjectMapper(); @PostMapping(&quot;/request-body-json-v1&quot;) public void requestBodyJsonV1(HttpServletRequest req, HttpServletResponse res) throws IOException { ServletInputStream inputStream = req.getInputStream(); String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8); log.info(&quot;messageBody= {}&quot;, messageBody); HelloData helloData = objectMapper.readValue(messageBody, HelloData.class); log.info(&quot;username={}, age={}&quot;, helloData.getUsername(), helloData.getAge()); res.getWriter().write(&quot;ok&quot;); } @RequestBody123456789@ResponseBody@PostMapping(&quot;/request-body-json-v2&quot;)public String requestBodyJsonV2(@RequestBody String messageBody) throws IOException { log.info(&quot;messageBody= {}&quot;, messageBody); HelloData helloData = objectMapper.readValue(messageBody, HelloData.class); log.info(&quot;username={}, age={}&quot;, helloData.getUsername(), helloData.getAge()); return &quot;Ok&quot;;} @RequestBody 에 직접 만든 객체를 지정할 수 있다12345678910111213@ResponseBody@PostMapping(&quot;/request-body-json-v3&quot;)public String requestBodyJsonV3(@RequestBody HelloData helloData) { log.info(&quot;username={}, age={}&quot;, helloData.getUsername(), helloData.getAge()); return &quot;Ok&quot;;}@ResponseBody@PostMapping(&quot;/request-body-json-v5&quot;)public HelloData requestBodyJsonV5(@RequestBody HelloData data) { log.info(&quot;username= {}, age= {}&quot;, data.getUsername(), data.getAge()); return data;} HttpEntity를 사용해서 객체로 데이터 저장 가능하다.1234567891011 @ResponseBody @PostMapping(&quot;/request-body-json-v4&quot;) public String requestBodyJsonV4(HttpEntity&lt;HelloData&gt; httpEntity) { HelloData data = httpEntity.getBody(); log.info(&quot;username= {}, age= {}&quot;, data.getUsername(), data.getAge()); return &quot;Ok&quot;; } } HttpEntity , @RequestBody 를 사용하면 HTTP 메시지 컨버터가 HTTP 메시지 바디의 내용을 우리가 원하는 문자나 객체 등으로 변환해준다. HTTP 응답 처리 우리가 이전에 본 spring MVC 구조에서, Controller는 ModelAndView에 경로를 담아서 반환했다. 하지만, annotation 기반의 @controller에서는 다른 것들 –String, void 등도 가능하다. 이것이 어떻게 가능한지에 대해서는 다음 장에서 살펴보겠다. 여기서 우리는 스프링에서 응답 데이터를 만들고 반환하는 기능들에 대해서 알아보고자 한다. 123456789101112@Controllerpublic class SpringMemberListControllerV1 { private MemberRepository memberRepository = MemberRepository.getInstance(); @RequestMapping(&quot;/springmvc/v1/members&quot;) public ModelAndView process(){ List&lt;Member&gt; members = memberRepository.findAll(); ModelAndView modelAndView = new ModelAndView(&quot;members&quot;); modelAndView.addObject(&quot;members&quot;, members); return modelAndView; }} 스프링 서버에서 응답 데이터를 만드는 방법 static resource: 해당 파일(.html)을 변경 없이 그대로 서비스하는 것 view template: 뷰 템플릿을 거쳐서 HTML이 생성되고, 뷰가 응답을 만들어서 전달한다 HTTP message view로 전달12345678910@Controllerpublic class ResponseViewController { @RequestMapping(&quot;/response-view-v1&quot;) public ModelAndView responseViewV1() { ModelAndView modelAndView = new ModelAndView(&quot;response/hello.html&quot;) .addObject(&quot;data&quot;, &quot;hello, view-V1&quot;); return modelAndView; }} 12345678@RequestMapping(&quot;/response-view-v2&quot;)public String responseViewV2(Model model) { model.addAttribute(&quot;data&quot;, &quot;hello, view-v2&quot;); return &quot;response/hello.html&quot;;} response/hello 로 뷰 리졸버가 실행되어서 뷰를 찾고, 렌더링 한다Http API view template을 거치지 않고, 직접 Http 메시지 바디에 JSON 같은 형식으로 데이터를 담아서 보내는 방법 12345678910111213141516@Controller//@RestController public class ResponseBodyController { @GetMapping(&quot;/response-body-string-v1&quot;) public void responseBodyV1(HttpServletResponse response) throws IOException { response.getWriter().write(&quot;ok&quot;); } /** * HttpEntity, ResponseEntity(Http Status 추가) * @return */ @GetMapping(&quot;/response-body-string-v2&quot;) public ResponseEntity&lt;String&gt; responseBodyV2() { return new ResponseEntity&lt;&gt;(&quot;ok&quot;, HttpStatus.OK); } 12345@ResponseBody@GetMapping(&quot;/response-body-string-v3&quot;)public String responseBodyV3() { return &quot;ok&quot;;} @ResponseBody 를 사용하면 view를 사용하지 않고, HTTP 메시지 컨버터를 통해서 HTTP 메시지를 직접 입력할 수 있다 123456789101112131415161718 @GetMapping(&quot;/response-body-json-v1&quot;) public ResponseEntity&lt;HelloData&gt; responseBodyJsonV1() { HelloData helloData = new HelloData(); helloData.setUsername(&quot;userA&quot;); helloData.setAge(20); return new ResponseEntity&lt;&gt;(helloData, HttpStatus.OK); } @ResponseStatus(HttpStatus.OK) @ResponseBody @GetMapping(&quot;/response-body-json-v2&quot;) public HelloData responseBodyJsonV2() { HelloData helloData = new HelloData(); helloData.setUsername(&quot;userA&quot;); helloData.setAge(20); return helloData; }}","link":"/2021/07/15/%5Bspring%20MVC%5D%20@Controller/"},{"title":"[spring MVC] Message Converter","text":"Message Converter 사용 이유 @ResponseBody를 사용하면, Http body에 문자내용을 직접 반환하게 된다. 이때, viewResolver가 아니라 HttpMessageConverter가 동작하게 된다. 더 정확하게, spring MVC는 다음의 경우에 messageConverter를 적용한다. Http 요청일때: @ResquestBody, HttpEntity http 응답일때: QresponseBody, HttpEntity HttpMessageConverter Interface1234567891011121314151617181920212223package org.springframework.http.converter;...public interface HttpMessageConverter&lt;T&gt; { boolean canRead(Class&lt;?&gt; clazz, @Nullable MediaType mediaType); boolean canWrite(Class&lt;?&gt; clazz, @Nullable MediaType mediaType); List&lt;MediaType&gt; getSupportedMediaTypes(); default List&lt;MediaType&gt; getSupportedMediaTypes(Class&lt;?&gt; clazz) { return (canRead(clazz, null) || canWrite(clazz, null) ? getSupportedMediaTypes() : Collections.emptyList()); } T read(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException; void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException;} canRead(), canWrite(): converter가 해당 class, 미디어타입을 지원하는지 확인한다. read() , write() : 컨버터를 통해서 메시지를 읽고 쓴다. springBoot 기본 message converter 우선순위 converter 0 ByteArrayHttpMessageConverter 1 StringHttpMessageConverter 2 MappingJackson2HttpMessageConverter 대상 클래스 타입과 미디어 타입 둘을 체크해서 사용여부를 결정한다. 만약 만족하지 않으면 다음 메시지 컨버터로 우선순위가 넘어간다. converter별 지원 클래스타입과 미디어 타입 Http request 데이터 읽기 흐름 http 요청이 오고, Controller에서 @RequestBody 또는 HttpEntity 파리미터를 사용한다고 가정하자. messageConverter가 메시지를 읽을 수 있는지 확인하기 위해 canRead()를 호출한다. 이때, (1) 대상 class의 타입을 지원하는지 확인한다. e.g., byte[], String, Hellodata 등. (2) 요청의 미디어타입(content-type)을 지원하는지 확인한다. e.g., text/plain, application/json, / canRead() 조건을 만족하면 read()를 호출해서 객체를 생성하고 반환한다. messageConverter의 작동 시점 우리는 spring MVC 요청흐름을 파악한 바 있다.[^1] client가 Http 요청을 보내면, DispatcherServlet에서 HandlerMapping으로 handler를 조회한다. @RequestMapping의 경우, RequestMappingHandlerMapping가 실행한다. handler를 찾은 후 HandlerAdapter로 handler를 실행할 수 있는 어댑터를 찾는다. @RequestMapping의 경우, RequestMappingHandlerAdapter가 실행되는데, 이 어댑터가 내부에서 해당 controller를 실행한다. DispatcherServlet으로 modelAndView 반환한다. RequestMappingHandlerAdapter에서 controller의 @RequestBody, HttpEntity, HttpServletRequest, Model 등을 처리해준다.[^2] RequestMappingHandlerAdapter는 ArgumentResolver를 호출해서 controller가 필요로 하는 parameter의 값(객체)를 생성한다. Adapter는 controller를 호출하면서 그 값을 넘겨준다. ArgumentResolver ArgumentResolver: HandlerMethodArgumentResolverInterface 1234567891011package org.springframework.web.method.support;public interface HandlerMethodArgumentResolver {- boolean supportsParameter(MethodParameter parameter); @Nullable Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;} ArgumentResolver 의 supportsParameter() 를 호출해서 해당 파라미터를 지원하는지 체크하고,지원하면 resolveArgument() 를 호출해서 실제 객체를 생성한다. 그리고 이렇게 생성된 객체가 컨트롤러호출시 넘어가는 것이다. ReturnValueHandler HandlerMethodReturnValuehandler는 응답 값을 변환하고 처리한다. ModelAndView, @ResponseBody, HttpEntity, String 등https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-annreturn-types message Converter가 호출되는 곳 요청할 때: @ResponseBody는 HandlerMethodArgumentResolver를 구현한 RequestResponseBodyMethodProcessor에 의해 처리된다. (HttpEntity는 HttpEntityMethodProcessor) supportsParameter에서 ResponseBody를 체크한 후, resolveArgument()에서 readWithMessageConverters를 사용한다. Object 만들어서 반환해준다. 이 ArgumentResolver들이 messageConverter를 사용해서 필요한 객체를 생성한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package org.springframework.web.servlet.mvc.method.annotation;public class RequestResponseBodyMethodProcessor extends AbstractMessageConverterMethodProcessor { public RequestResponseBodyMethodProcessor(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { super(converters); } public RequestResponseBodyMethodProcessor(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters, @Nullable ContentNegotiationManager manager) { super(converters, manager); } public RequestResponseBodyMethodProcessor(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters, @Nullable List&lt;Object&gt; requestResponseBodyAdvice) { super(converters, null, requestResponseBodyAdvice); } /** * Complete constructor for resolving {@code @RequestBody} and handling * {@code @ResponseBody}. */ public RequestResponseBodyMethodProcessor(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters, @Nullable ContentNegotiationManager manager, @Nullable List&lt;Object&gt; requestResponseBodyAdvice) { super(converters, manager, requestResponseBodyAdvice); } @Override public boolean supportsParameter(MethodParameter parameter) { return parameter.hasParameterAnnotation(RequestBody.class); } @Override public boolean supportsReturnType(MethodParameter returnType) { return (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) || returnType.hasMethodAnnotation(ResponseBody.class)); } @Override public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception { parameter = parameter.nestedIfOptional(); Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType()); String name = Conventions.getVariableNameForParameter(parameter); if (binderFactory != null) { WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name); if (arg != null) { validateIfApplicable(binder, parameter); if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) { throw new MethodArgumentNotValidException(parameter, binder.getBindingResult()); } } if (mavContainer != null) { mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult()); } } return adaptArgumentIfNecessary(arg, parameter); } @Override protected &lt;T&gt; Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter, Type paramType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException { HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class); Assert.state(servletRequest != null, &quot;No HttpServletRequest&quot;); ServletServerHttpRequest inputMessage = new ServletServerHttpRequest(servletRequest); Object arg = readWithMessageConverters(inputMessage, parameter, paramType); if (arg == null &amp;&amp; checkRequired(parameter)) { throw new HttpMessageNotReadableException(&quot;Required request body is missing: &quot; + parameter.getExecutable().toGenericString(), inputMessage); } return arg; } 응답 시: @ResponseBody, HttpEntity를 처리하는 ReturnValueHandler가 messageConverter를 호출해서 응답 결과를 만든다. Reference 김영한(2021-03-21), Spring MVC 1편, Ch6 S13 ~ S14","link":"/2021/07/15/%5Bspring%20MVC%5D%20Message%20Converter/"}],"tags":[],"categories":[]}